===============================================================================
Thoughts, questions, musings on my saltstack.
===============================================================================

Adding a 'backup' feature.
    Each of the bottom states should contain the methods necessary for all of
    the things that affect it. For instance, I worked in the iptable rules to
    the bottom state, so that I can have the individual services can 'punch'
    holes needed to operate. This way, I can more easily see what each service
    requires individually, rather than digging through a top level state for
    the correct service.

    Taking this a step further, I would like to add backups to the bottom
    service.sls, and this further might fix the issue with SeLinux and
    such. If each service contains all of it's configuration for things
    like ACL and files to backup, at the top level it is as simple as
    saying 'services.backup' and letting each service.sls handle its
    configuration for 'doing it properly'.

    As backups are considered 'critical' to any real service level,
    I would like to add this in at an 'all' top level, and make sure
    that all services have the settings for their own backup.

    Something to consider here, is what happens when I want to use a
    different backup program. I have to be wary of changes at every
    single service if I have hardcoded it, which is something I want
    to design away from. Additionally, If each individual state
    is considered separate during the (obnam) run, it will have
    issues with 'generation' cleanups. They need to pass their
    options 'upward' toward the top level, that it is included in
    the 'entire' server backup, not added on afterward.


I need to configure the iptables for transmission. I also need to add the
logic in to handle the fact that transmission is sketchy about how they
handle config files, because of the 'web interface'. It will write the
config it has in memory back to disk. Meaning, it will wipe out all
changes made while the daemon is running. You have to stop the server
to modify the config file.

I need to figure out how to add the iptables in now. Make sure that I have
transmission set to not screw up, and retest tor with the iptables setup.
I really want to firewall everything off for a change.



New idea with the security angle: I like the idea of security levels,
that are handled via a state, and bootstrap all prior security levels
into a hardened machine. There is a bit of contention, about how to handle
some of the various hardening techniques, such as selinux. Selinux
requires configuration 'per service', which is unknown to the generic
state file that declares the level. It would also be unweildy to handle
the security configuration in each individual service state file. I need
to decide how and where the security configurations will reside, and how
to 'make them aware' of the services that are being run on that box.


I would like to have a script that turns my saltstack states into
'readable' documentation.

Email security
# Just things for an email server, such as greylisting, tarpits, etc..


Pillars seem to be a good 'os level' template to make the packages
generic in the salt states, rather than having logic in the salt states
to handle each of the different packagenames across platforms (think:
transmission-d on linux vs windows)


# IDEAS for making my overall network more robust with an easy maintenance.
#        - security.firewall <- could also 'monitor' state and re-enable it
#            Thoughts on this; I could completely 'lock down' the firewall
#            at the top level, and 'punch' the necessarry holes at the service
#            level .sls files. This way, I have documentation at the service
#            level about what is required, and it also acts as a 'whitelist'
#            that will minimize the attack surface.

#        - role.cloudserver <- Have capability to hook into my phone and such.
#        - security.pub_keys <- Copy all keys to all servers.. when master keyring updated, "push all".state
#        - security.grsecurity <- the hardened kernel.
#        - monitoring.bandwidthshaper < script setup for my online hosts
#        - monitoring.client
#        - security.chroot <- This one I am interested in looking into


# THE FOLLOWING TWO EXAMPLES MAY BE SWITCHED TO cluster* as the names,
# rather than the device naming convention I have used. That way I could
# add new nodes of _anytype_ with the name alone.
#    'raspberrypi-*':
#        - roles.cluster
#        - roles.mesh


#    'odroid-*:
#        - roles.cluster
#        - roles.mesh

DONE!! Using 'include'(s)
    I am having a bit of trouble understanding the state layout for a tree
    deeper than 'one level', as far as best practice goes.
    How do I handle a tree as follows?:
        role.webserver (sls file)
            webserver.sls contains service.name <- Here, syntax here?? (use include)
                nginx.init (where the package is actually referenced, and config set)
    Essentially, I need to figure out how to define a generic role, and then
    define a service, that references the actual package further down.

Issues with iptables script, and the order in which the services punch
into the firewall. I also have the issue of duplicate punch rules if
I run the state more than once. I really need to know how to have
scripts have conditional runs on other scripts, or how to 'check' for a state.
This seems to be already implemented, so I need to start grinding at it.


Tor work. I am having issues with my tornode not communicating it's
directory services to other nodes. While watching the logfile, I noticed
that it made reference to the /etc/hosts file. It makes me wonder if I
should place my wan ip somehere in there.

